CREATE OR REPLACE PACKAGE DBVECTORIAL
IS
    PROCEDURE SEARCH_VECTOR(
        P_NAME_COLLECT IN VARCHAR2,
        P_V1 IN V_BINARY_DOUBLE,
        P_ROWS IN NUMBER,
        C1 OUT SYS_REFCURSOR
    );
    FUNCTION EUCLIDIAN_DISTANCE (
        P_V1 V_BINARY_DOUBLE,
        P_V2 V_BINARY_DOUBLE
    ) RETURN BINARY_DOUBLE;
    
    FUNCTION DOT_PRODUCT (
        P_V1 IN V_BINARY_DOUBLE,
        P_V2 IN V_BINARY_DOUBLE
    ) RETURN BINARY_DOUBLE;
    
    FUNCTION COSINES_SIMILITARY (
        P_V1 IN V_BINARY_DOUBLE,
        P_V2 IN V_BINARY_DOUBLE
    ) RETURN BINARY_DOUBLE;
    
END DBVECTORIAL;
/--split
CREATE OR REPLACE PACKAGE BODY DBVECTORIAL
IS
    PROCEDURE SEARCH_VECTOR(
        P_NAME_COLLECT IN VARCHAR2,
        P_V1 IN V_BINARY_DOUBLE,
        P_ROWS IN NUMBER,
        C1 OUT SYS_REFCURSOR
    ) IS
        V_ORDER T_SIMILITARY_METHODS.SORT_ORDER%TYPE;
        V_METHOD T_SIMILITARY_METHODS.NAME_METHOD%TYPE;
        V_SQL_SEARCH CLOB;
    BEGIN
    
        V_SQL_SEARCH:='
            SELECT 
                TDV.TAGS,
                TDV.DESCRIPTION,
                TDV.VECTOR,
                TDV.CREATION_DATE,
                DBVECTORIAL.#METHOD#(
                    :V1,
                    TDV.VECTOR
                ) AS SIMILITARY
            FROM 
                T_DATA_VECTOR TDV, 
                T_COLLECTION TC 
            WHERE 
                TC.ID_COLLECTION = TDV.COLLECTION_ID 
                AND TC.NAME_COLLECTION = ''#NAME#''
            ORDER BY SIMILITARY #ORDER#
            FETCH FIRST #ROWS# ROWS ONLY
        ';
        SELECT
            TSM.NAME_METHOD,
            TSM.SORT_ORDER 
        INTO
            V_METHOD,
            V_ORDER
        FROM 
            T_SIMILITARY_METHODS TSM,
            T_COLLECTION TC
        WHERE 
            TSM.ID_METHOD = TC.SEARCH_METHOD_ID AND
            TC.NAME_COLLECTION = P_NAME_COLLECT;
        
        V_SQL_SEARCH := REPLACE(V_SQL_SEARCH, '#NAME#', P_NAME_COLLECT);
        V_SQL_SEARCH := REPLACE(V_SQL_SEARCH, '#METHOD#', V_METHOD);
        V_SQL_SEARCH := REPLACE(V_SQL_SEARCH, '#ORDER#', V_ORDER);
        V_SQL_SEARCH := REPLACE(V_SQL_SEARCH, '#ROWS#', P_ROWS);
    
        DBMS_OUTPUT.PUT_LINE(V_SQL_SEARCH);
        OPEN C1 FOR V_SQL_SEARCH USING P_V1;
        
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('ERRORES ENCONTRADOS');
    END SEARCH_VECTOR;
    
    FUNCTION DOT_PRODUCT (
        P_V1 IN V_BINARY_DOUBLE,
        P_V2 IN V_BINARY_DOUBLE
    ) RETURN BINARY_DOUBLE
    IS
        V1_LEN BINARY_DOUBLE;
        V2_LEN BINARY_DOUBLE;
        DOT_PRODUCT_RESULT BINARY_DOUBLE := 0;
    BEGIN
        V1_LEN := P_V1.COUNT;
        V2_LEN := P_V2.COUNT;
        
        IF V1_LEN <> V2_LEN THEN
            RAISE_APPLICATION_ERROR(-20001,'EL TAMAÑO DE LOS VECTORES NO COINCIDE. ACCION INTERRUMPIDA');
        END IF;
        
        FOR I IN 1..V1_LEN LOOP
            DOT_PRODUCT_RESULT := DOT_PRODUCT_RESULT +( P_V1(I) * P_V2(I) );
        END LOOP;
        RETURN DOT_PRODUCT_RESULT;
    END DOT_PRODUCT;
    
    FUNCTION NORMA_VECTOR(
        P_V IN V_BINARY_DOUBLE
    ) RETURN BINARY_DOUBLE
    IS
        RESULT_NORMA BINARY_DOUBLE := 0;
    BEGIN
        
        FOR I IN 1..P_V.COUNT LOOP
            RESULT_NORMA := RESULT_NORMA + POWER(P_V(I),2);
        END LOOP;
        
        RETURN SQRT(RESULT_NORMA);
    END NORMA_VECTOR;
        
    FUNCTION COSINES_SIMILITARY (
        P_V1 IN V_BINARY_DOUBLE,
        P_V2 IN V_BINARY_DOUBLE
    ) RETURN BINARY_DOUBLE
    IS    
        NORMA_V1 BINARY_DOUBLE;
        NORMA_V2 BINARY_DOUBLE;
        DOT_PRODUCT_V BINARY_DOUBLE;
        
    BEGIN
        
        DOT_PRODUCT_V := DOT_PRODUCT ( P_V1, P_V2 );
        NORMA_V1:= NORMA_VECTOR(P_V1);
        NORMA_V2:= NORMA_VECTOR(P_V2);
        
        IF NORMA_V1 = 0 OR NORMA_V2 = 0 THEN
                RAISE_APPLICATION_ERROR(-20002, 'EXISTE ALGUNA NORMA CON VALOR CERO');
        END IF;
            
        RETURN DOT_PRODUCT_V / (NORMA_V1 * NORMA_V2);
    END COSINES_SIMILITARY;
    
    FUNCTION EUCLIDIAN_DISTANCE (
        P_V1 V_BINARY_DOUBLE,
        P_V2 V_BINARY_DOUBLE
    ) RETURN BINARY_DOUBLE
    IS
        V1_LEN NUMBER;
        V2_LEN NUMBER;
        DIST BINARY_DOUBLE := 0;
    BEGIN
        V1_LEN := P_V1.COUNT;
        V2_LEN := P_V2.COUNT;
        
        IF V1_LEN <> V2_LEN THEN
            RAISE_APPLICATION_ERROR(-20001,'EL TAMAÑO DE LOS VECTORES NO COINCIDE. ACCION INTERRUMPIDA');
        END IF;
        
        
        FOR I IN 1..V1_LEN LOOP
            DIST := DIST + POWER(P_V1(I) - P_V2(I), 2);
            DBMS_OUTPUT.PUT_LINE(DIST);
        END LOOP;
        
        RETURN SQRT(DIST);
    END EUCLIDIAN_DISTANCE;
    
END DBVECTORIAL;